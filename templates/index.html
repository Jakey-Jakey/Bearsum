<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pocket Summarizer - Bearhacks Edition</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body>

    <header class="app-header">
        <h1>Pocket Summarizer <span class="theme-accent">(Bearhacks Edition)</span></h1>
    </header>

    <div class="container">

        <!-- Display Flashed Messages -->
        {% with messages = get_flashed_messages(with_categories=true) %}
          {% if messages %}
            <div class="flash-messages">
              {% for category, message in messages %}
                <div class="flash flash-{{ category }}">{{ message }}</div>
              {% endfor %}
            </div>
          {% endif %}
        {% endwith %}

        <!-- Display Explicit Error Messages (if passed) -->
        {% if error_messages %}
            <div class="error-area flash-messages">
                <h4>Errors Occurred During Last Process:</h4>
                {% for error in error_messages %}
                    <div class="flash flash-error">{{ error }}</div>
                {% endfor %}
            </div>
        {% endif %}


        <!-- Upload Form Section -->
        <section class="upload-section">
            <h2>Upload Your Files</h2>
            <p>Drag & drop your notes (.txt, .md) or browse.</p>
            <div class="file-info">
                Max files: {{ config.MAX_FILES }}, Max size per file: {{ config.MAX_FILE_SIZE_MB }}MB
            </div>

            <!-- Add data attributes for JS config -->
            <form method="post"
                  enctype="multipart/form-data"
                  class="upload-form"
                  id="upload-form"
                  action="{{ url_for('process_files') }}"
                  data-max-files="{{ config.MAX_FILES }}"
                  data-max-file-size-mb="{{ config.MAX_FILE_SIZE_MB }}"
                  data-is-processing="{{ is_processing | lower }}" {# Pass boolean as string #}
                  data-task-id="{{ task_id if task_id else '' }}" {# Pass task_id #}
                  >

                <!-- Hidden Actual File Input -->
                <input type="file" id="files" name="files" multiple required accept=".txt,.md" class="visually-hidden">

                <!-- Drag and Drop Zone -->
                <div id="drop-zone" class="drop-zone">
                    <p>Drag & Drop Files Here</p>
                    <p>or</p>
                    <a href="#" id="browse-files-link" class="btn btn-browse">Browse Files</a>
                </div>

                <!-- File List Display -->
                <div id="file-list-display" class="file-list-display">
                    <p><em>No files selected. Drag & drop or browse.</em></p>
                </div>

                <!-- Summary Level Options (Ghost Button Style) -->
                <div class="form-group">
                    <label>Summary Detail Level:</label>
                    <div class="radio-group ghost-buttons"> {# Added class #}
                        <label>
                            <input type="radio" name="summary_level" value="short" class="visually-hidden"> {# Hide input #}
                            <span>Short</span> {# Wrap text #}
                        </label>
                        <label>
                            <input type="radio" name="summary_level" value="medium" checked class="visually-hidden">
                            <span>Medium</span>
                        </label>
                        <label>
                            <input type="radio" name="summary_level" value="comprehensive" class="visually-hidden">
                            <span>Comprehensive</span>
                        </label>
                    </div>
                </div>

                <!-- Submit Button -->
                <div class="form-group submit-group">
                    <button type="submit" class="btn btn-submit" id="submit-button">Summarize Files</button>
                </div>
            </form>
        </section>

        <!-- Wrapper for Processing Indicator Transition -->
        <div id="processing-indicator-wrapper" class="processing-indicator-wrapper {% if not is_processing %}hidden{% endif %}">
            <section id="processing-indicator" class="processing-indicator">
                 <div class="spinner"></div>
                 <p>Processing your files... please wait.</p>
                 <div class="status-log live-status-area" id="live-status-log">
                     <h4>Live Status:</h4>
                     <p id="latest-status" class="latest-status-message">Initializing...</p>
                 </div>
            </section>
        </div>

        <!-- Wrapper for Results Section Transition -->
        <div id="results-container-wrapper" class="results-container-wrapper {% if is_processing or not (summary_html or summary_raw) %}hidden{% endif %}">
            <section class="results-container" id="results-area">
                {% if summary_html or summary_raw %}
                    <div class="results-area summary-section">
                        <h2>Summary</h2>
                        <div class="view-toggle">
                            <button type="button" class="btn btn-toggle active" data-view="rendered">Rendered View</button>
                            <button type="button" class="btn btn-toggle" data-view="raw">Raw Text</button>
                        </div>
                        <!-- Wrapper for view toggle transition -->
                        <div class="summary-view-wrapper" id="summary-view-wrapper">
                            <div id="summary-rendered" class="summary-rendered">
                                {% if summary_html %}{{ summary_html | safe }}{% else %}<p><em>(Could not render summary)</em></p>{% endif %}
                            </div>
                            <div id="summary-raw" class="summary-raw hidden">
                                <pre id="summary-text-raw">{{ summary_raw }}</pre>
                            </div>
                        </div>
                        <div class="action-buttons">
                             <button type="button" id="copy-button" class="btn btn-copy">Copy Raw Text</button>
                             {# Only show download if raw summary exists and is not an error message #}
                             {% if summary_raw and not summary_raw.startswith("Error:") %}
                             <a href="{{ url_for('download_summary') }}" class="btn btn-download">Download Raw (.txt)</a>
                             {% endif %}
                        </div>
                    </div>
                {% endif %}
                {# Final status log display removed as live status covers it #}
            </section>
        </div>

    </div> <!-- /container -->

    <!-- JavaScript -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- Element References ---
            const uploadForm = document.getElementById('upload-form');
            const submitButton = document.getElementById('submit-button');
            // Reference the wrappers for transitions
            const processingIndicatorWrapper = document.getElementById('processing-indicator-wrapper');
            const resultsContainerWrapper = document.getElementById('results-container-wrapper');
            // Keep references to inner content if needed
            const processingIndicator = document.getElementById('processing-indicator');
            const resultsArea = document.getElementById('results-area');
            const latestStatusElement = document.getElementById('latest-status');
            const copyButton = document.getElementById('copy-button');
            const summaryRawTextElement = document.getElementById('summary-text-raw');
            const viewToggles = document.querySelectorAll('.view-toggle .btn-toggle');
            const renderedView = document.getElementById('summary-rendered');
            const rawView = document.getElementById('summary-raw');
            const summaryViewWrapper = document.getElementById('summary-view-wrapper'); // Wrapper for view toggle
            const fileInput = document.getElementById('files');
            const dropZone = document.getElementById('drop-zone');
            const fileListDisplay = document.getElementById('file-list-display');
            const browseFilesLink = document.getElementById('browse-files-link');

            // --- Config ---
            const MAX_FILES = parseInt(uploadForm?.dataset.maxFiles || '5');
            const MAX_FILE_SIZE_MB = parseInt(uploadForm?.dataset.maxFileSizeMb || '1');
            const MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024;
            const ALLOWED_EXTENSIONS = ['txt', 'md'];

            // --- Initial State from Flask ---
            const isProcessing = uploadForm?.dataset.isProcessing === 'true';
            const taskId = uploadForm?.dataset.taskId;
            let eventSource = null;

            // --- Helper: Update File List Display ---
            function updateFileList(files) {
                if (!fileListDisplay) return;
                fileListDisplay.innerHTML = ''; // Clear previous list
                if (!files || files.length === 0) {
                    fileListDisplay.innerHTML = '<p><em>No files selected. Drag & drop or browse.</em></p>';
                    return;
                }

                const list = document.createElement('ul');
                Array.from(files).forEach((file, index) => { // Add index
                    const li = document.createElement('li');
                    let errorMsg = '';
                    const fileExt = file.name.split('.').pop()?.toLowerCase() || '';
                    if (file.size > MAX_FILE_SIZE_BYTES) {
                        errorMsg = ` <span class="file-error">(Too large: > ${MAX_FILE_SIZE_MB}MB)</span>`;
                    } else if (!ALLOWED_EXTENSIONS.includes(fileExt)) {
                         errorMsg = ` <span class="file-error">(Invalid type)</span>`;
                    }

                    li.innerHTML = `${file.name} <span class="file-size">(${(file.size / 1024).toFixed(1)} KB)</span>${errorMsg}`;
                    if (errorMsg) li.classList.add('has-error');
                    li.style.animationDelay = `${index * 0.05}s`; // Stagger animation
                    list.appendChild(li);
                });
                fileListDisplay.appendChild(list);

                if (files.length > MAX_FILES) {
                     const errorLi = document.createElement('li');
                     errorLi.innerHTML = `<span class="file-error">Error: Too many files selected (max ${MAX_FILES}).</span>`;
                     errorLi.classList.add('has-error');
                     errorLi.style.animationDelay = `${files.length * 0.05}s`; // Also stagger error message
                     list.appendChild(errorLi);
                }
            }

             // --- Helper: Validate Files ---
             function validateFiles(files) {
                if (!files || files.length === 0) return false; // No files is invalid for submission
                if (files.length > MAX_FILES) return false; // Too many files

                for (const file of files) {
                    const fileExt = file.name.split('.').pop()?.toLowerCase() || '';
                    if (file.size > MAX_FILE_SIZE_BYTES || !ALLOWED_EXTENSIONS.includes(fileExt)) {
                        return false; // Individual file error
                    }
                }
                return true; // All checks passed
            }

            // --- Helper: Show/Hide Wrappers for Transition ---
            function showElementWrapper(wrapper) {
                if (!wrapper) return;
                wrapper.classList.remove('hidden');
            }
            function hideElementWrapper(wrapper) {
                if (!wrapper) return;
                wrapper.classList.add('hidden');
            }

            // --- Helper: Set View Wrapper Height ---
            function setViewWrapperHeight() {
                 if (!summaryViewWrapper) return;
                 const activeView = summaryViewWrapper.querySelector(':not(.hidden)');
                 if (activeView) {
                     // Use scrollHeight for accurate content height
                     summaryViewWrapper.style.minHeight = `${activeView.scrollHeight}px`;
                 } else {
                     summaryViewWrapper.style.minHeight = '100px'; // Default fallback
                 }
            }


            function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
            function highlight(e) { dropZone?.classList.add('dragover'); }
            function unhighlight(e) { dropZone?.classList.remove('dragover'); }

            function handleDrop(e) {
                 const dt = e.dataTransfer;
                 const files = dt.files;
                 try {
                      fileInput.files = files;
                      updateFileList(files); // Update UI
                 } catch (err) {
                      console.error("Error setting file input files:", err);
                      alert("There was an error processing the dropped files. Please try the 'browse' link instead.");
                      updateFileList(null); // Clear list on error
                 }
            }


            // --- Drag and Drop Logic ---
            if (dropZone && fileInput && fileListDisplay) {
                 ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                     dropZone.addEventListener(eventName, preventDefaults, false);
                     document.body.addEventListener(eventName, preventDefaults, false);
                 });
                 ['dragenter', 'dragover'].forEach(eventName => dropZone.addEventListener(eventName, highlight, false));
                 ['dragleave', 'drop'].forEach(eventName => dropZone.addEventListener(eventName, unhighlight, false));
                 dropZone.addEventListener('drop', handleDrop, false);

                 if (browseFilesLink) {
                      browseFilesLink.addEventListener('click', (e) => {
                          e.preventDefault();
                          fileInput.click();
                      });
                 }
                 dropZone.addEventListener('click', (event) => {
                     if (!browseFilesLink || !event.target.isSameNode(browseFilesLink)) {
                        fileInput.click();
                     }
                 });

                 fileInput.addEventListener('change', function() { updateFileList(this.files); });
                 updateFileList(fileInput.files); // Initial update
            }


            // --- SSE Connection Function ---
            function connectSSE(taskId) {
                // Ensure wrappers are referenced
                if (!taskId || !processingIndicatorWrapper || !resultsContainerWrapper || !latestStatusElement) return;
                console.log(`Connecting to SSE stream for task: ${taskId}`);
                eventSource = new EventSource(`/stream?channel=${taskId}`);

                eventSource.onopen = function() {
                    console.log("SSE connection opened.");
                    showElementWrapper(processingIndicatorWrapper); // Use wrapper helper
                    hideElementWrapper(resultsContainerWrapper);   // Use wrapper helper
                    latestStatusElement.textContent = 'Connection established... waiting for updates.';
                    latestStatusElement.classList.remove('animate-new'); // Reset animation class
                    latestStatusElement.style.color = '';
                };

                eventSource.onmessage = function(event) {
                     console.log("SSE message received:", event.data);
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'status' && latestStatusElement) {
                            // Update text and trigger animation
                            latestStatusElement.textContent = data.message;
                            latestStatusElement.classList.remove('animate-new'); // Remove class briefly
                            void latestStatusElement.offsetWidth; // Force reflow
                            latestStatusElement.classList.add('animate-new'); // Add class to trigger animation
                        }
                        if (data.type === 'completed' || data.type === 'error') {
                            console.log(`Processing ${data.type}. Closing SSE connection and reloading.`);
                            if (eventSource) { eventSource.close(); eventSource = null; }
                            latestStatusElement.textContent = `Processing ${data.type}. Reloading results...`;
                            // Add a slight delay before reload to allow user to read final status
                            setTimeout(() => { window.location.reload(); }, 1200); // Increased delay
                        }
                    } catch (e) {
                        console.error("Failed to parse SSE message or update UI:", e);
                         if(latestStatusElement) latestStatusElement.textContent = "Error processing status update.";
                    }
                };

                eventSource.onerror = function(err) {
                    console.error("SSE connection error:", err);
                    if (latestStatusElement) {
                         latestStatusElement.textContent = "Status update connection failed. Please refresh manually for results.";
                         latestStatusElement.style.color = 'var(--color-error-text)';
                         latestStatusElement.classList.remove('animate-new');
                    }
                    if (eventSource) { eventSource.close(); eventSource = null; }
                    // Hide processing indicator on error
                    hideElementWrapper(processingIndicatorWrapper);
                };
            }

            // --- Initial Page Load Logic ---
            if (isProcessing && taskId) {
                connectSSE(taskId);
            } else {
                hideElementWrapper(processingIndicatorWrapper); // Use wrapper helper
                 // Ensure results wrapper is shown if it should be (Flask logic handles initial hidden state)
                 if (resultsContainerWrapper && !resultsContainerWrapper.classList.contains('hidden')) {
                     showElementWrapper(resultsContainerWrapper);
                     setViewWrapperHeight(); // Set initial height for view toggle
                 }
            }

            // --- Form Submission Logic ---
            if (uploadForm && processingIndicatorWrapper && resultsContainerWrapper && fileInput && submitButton) {
                uploadForm.addEventListener('submit', function(event) {
                    const files = fileInput.files;
                    if (!validateFiles(files)) { // Use combined validation
                         alert("Please select valid files (check type, size, and count) before submitting.");
                         event.preventDefault(); return;
                    }
                    showElementWrapper(processingIndicatorWrapper); // Use wrapper helper
                    hideElementWrapper(resultsContainerWrapper);   // Use wrapper helper
                    submitButton.disabled = true;
                    if (latestStatusElement) {
                        latestStatusElement.textContent = 'Submitting files...';
                        latestStatusElement.classList.remove('animate-new'); // Reset animation class
                    }
                    // No need to prevent default if validation passes, let form submit
                });
            }

            // --- View Toggling Logic (Updated for Opacity/Visibility Transition) ---
             if (viewToggles.length > 0 && renderedView && rawView && summaryViewWrapper) {
                viewToggles.forEach(button => {
                    button.addEventListener('click', function() {
                        const viewToShow = this.getAttribute('data-view');

                        // Update active button state
                        viewToggles.forEach(btn => btn.classList.remove('active'));
                        this.classList.add('active');

                        // Toggle visibility using .hidden class for CSS transitions
                        if (viewToShow === 'rendered') {
                            renderedView.classList.remove('hidden');
                            rawView.classList.add('hidden');
                        } else {
                            renderedView.classList.add('hidden');
                            rawView.classList.remove('hidden');
                        }
                         // Update wrapper height after transition starts (or slightly after)
                         setTimeout(setViewWrapperHeight, 50); // Small delay allows DOM update
                    });
                });

                // Set initial view and height
                const hasRenderedContent = renderedView && !renderedView.classList.contains('hidden') && renderedView.innerText.trim() !== '' && !renderedView.querySelector('p')?.innerText.includes('Could not render summary');
                const hasRawContent = rawView && !rawView.classList.contains('hidden') && summaryRawTextElement && summaryRawTextElement.innerText.trim() !== '';

                if (resultsContainerWrapper && !resultsContainerWrapper.classList.contains('hidden')) { // Only run if results are visible
                    if (hasRenderedContent) {
                         renderedView.classList.remove('hidden'); rawView.classList.add('hidden');
                         viewToggles.forEach(btn => btn.classList.toggle('active', btn.getAttribute('data-view') === 'rendered'));
                    } else if (hasRawContent) {
                         renderedView.classList.add('hidden'); rawView.classList.remove('hidden');
                         viewToggles.forEach(btn => btn.classList.toggle('active', btn.getAttribute('data-view') === 'raw'));
                    } else {
                         renderedView.classList.remove('hidden'); rawView.classList.add('hidden');
                         viewToggles.forEach(btn => btn.classList.toggle('active', btn.getAttribute('data-view') === 'rendered'));
                    }
                    setViewWrapperHeight(); // Set initial height
                }
            }


            // --- Copy Button Logic ---
            if (copyButton && summaryRawTextElement) {
                // Ensure raw text exists and is not just whitespace or an error message
                const rawTextContent = summaryRawTextElement.innerText?.trim();
                if (rawTextContent && !rawTextContent.startsWith("Error:")) {
                    copyButton.style.display = 'inline-block'; // Ensure it's visible
                    copyButton.addEventListener('click', function() {
                        const textToCopy = summaryRawTextElement.innerText; // Copy original text including whitespace
                        console.log("Attempting to copy raw text...");
                        if (!navigator.clipboard) {
                            alert('Clipboard API not available (maybe insecure context/HTTP?). Please copy manually.');
                            return;
                        }
                        navigator.clipboard.writeText(textToCopy).then(function() {
                            console.log("Copy successful");
                            copyButton.innerText = 'Copied!';
                            copyButton.disabled = true;
                            setTimeout(function() {
                                copyButton.innerText = 'Copy Raw Text';
                                copyButton.disabled = false;
                            }, 1500);
                        }, function(err) {
                            console.error('Could not copy text: ', err);
                            alert('Failed to copy text. See console for details.');
                            copyButton.innerText = 'Copy Failed';
                             setTimeout(function() {
                                copyButton.innerText = 'Copy Raw Text';
                            }, 1500);
                        });
                    });
                } else {
                     console.log("Copy button hidden: No valid raw text content.");
                     copyButton.style.display = 'none'; // Hide if no valid content
                }
            } else if (copyButton) {
                 console.log("Copy button hidden: Target element not found or button itself missing.");
                 copyButton.style.display = 'none'; // Hide if elements missing
            }

            // Recalculate view wrapper height on window resize
            window.addEventListener('resize', setViewWrapperHeight);

        }); // End DOMContentLoaded
    </script>

</body>
</html>
